{"version":3,"sourceRoot":"","sources":["file:///Users/patricklake/Dev/personal/css_utilities/src/utils-exports/_row-scroll.scss","file:///Users/patricklake/Dev/personal/css_utilities/src/mixins/index.scss"],"names":[],"mappings":"AAQA,gCAEE,4BAEA,sDAEA,sEAEA,+FAGA,kEAGA,oEAEA,qFAIA,uHAKA,aACA,iBACA,uBACA,+BACA,8CACA,+CACA,sCACA,uCACA,cACA,6BAEA,kDACE,oBAGF,oCACE,yBACA,WACA,kCACA,kCAEA,mEAIA,wCACE,4BADF,wCACE,4BADF,wCACE,4BADF,wCACE,4BADF,wCACE,4BADF,wCACE,4BCrDJ,yBD2DM,8CACE,uCADF,8CACE,uCADF,8CACE,uCADF,8CACE,uCADF,8CACE,uCADF,8CACE,wCC5DR,yBD2DM,8CACE,uCADF,8CACE,uCADF,8CACE,uCADF,8CACE,uCADF,8CACE,uCADF,8CACE,wCC5DR,yBD2DM,8CACE,uCADF,8CACE,uCADF,8CACE,uCADF,8CACE,uCADF,8CACE,uCADF,8CACE,wCC5DR,yBD2DM,8CACE,uCADF,8CACE,uCADF,8CACE,uCADF,8CACE,uCADF,8CACE,uCADF,8CACE,wCC5DR,2BD2DM,gDACE,uCADF,gDACE,uCADF,gDACE,uCADF,gDACE,uCADF,gDACE,uCADF,gDACE,wCAOV,oBACE","sourcesContent":["\n@import '../base-vars';\n@import '../base-maps';\n@import '../mixins/';\n/* @import '../reset/'; */\n\n$number-per-row: (1, 2, 3, 4, 5, 6);\n\n.row-scroll,\n.row-scroll-reverse {\n  --row-scroll-width-sizer: 1; // How many cards fit in the container\n  // Use the column var from the row gutter classes to set these gaps\n  --row-scroll-flex-gap: #{var(--col-gutter-column, $space-md)};\n\n  --row-scroll-padding-spacer: calc((var(--container-padding) * 2) / 2);\n\n  --row-scroll-spacer: calc(\n    100vw - var(--container-width) + var(--row-scroll-padding-spacer)\n  );\n  --row-scroll-spacer-negative: calc(var(--row-scroll-spacer) * -1);\n\n  // * Child width: Get the percentage of the container that each card should take up\n  --row-scroll-width-base: calc(100% / var(--row-scroll-width-sizer));\n  // * Child width: Generate a multiplier to offset the gap width\n  --row-scroll-gap-offset: calc(\n    (100 - (100 / var(--row-scroll-width-sizer))) / 100\n  );\n  // * Child width: Calculate the width of the cards based on the number of cards that fit in the container\n  --row-scroll-width: calc(\n    var(--row-scroll-width-base) -\n      (var(--row-scroll-flex-gap) * var(--row-scroll-gap-offset))\n  );\n\n  display: flex;\n  flex-wrap: nowrap;\n  align-items: flex-start;\n  gap: var(--row-scroll-flex-gap);\n  margin-left: var(--row-scroll-spacer-negative);\n  margin-right: var(--row-scroll-spacer-negative);\n  padding-left: var(--row-scroll-spacer);\n  padding-right: var(--row-scroll-spacer);\n  overflow: auto;\n  scroll-snap-type: x mandatory;\n\n  &--stretch {\n    align-items: stretch;\n  }\n\n  & > * {\n    scroll-snap-align: center;\n    width: 100%;\n    min-width: var(--row-scroll-width);\n    max-width: var(--row-scroll-width);\n\n    transition: max-width 300ms ease-in-out, min-width 300ms ease-in-out;\n  }\n\n  @each $num in $number-per-row {\n    &.r-#{$num} {\n      --row-scroll-width-sizer: #{$num};\n    }\n  }\n  @each $bp, $px in $breakpoints {\n    @include respond-to(#{$px}) {\n      @each $num in $number-per-row {\n        &.r-#{$bp}-#{$num} {\n          --row-scroll-width-sizer: #{$num} !important;\n        }\n      }\n    }\n  }\n}\n\n.row-scroll-reverse {\n  flex-direction: row-reverse;\n}\n","@use 'sass:map';\n@use 'sass:meta';\n\n@mixin respond-to($breakpoint) {\n  $dir: if($is-mobile-first, min-width, max-width);\n\n  @media (#{$dir}: $breakpoint) {\n    @content;\n  }\n}\n\n@mixin xl-size() {\n  @include respond-to($screen-xl-min) {\n    @content;\n  }\n}\n\n@mixin lg-size() {\n  @include respond-to($screen-lg-min) {\n    @content;\n  }\n}\n\n@mixin md-size() {\n  @include respond-to($screen-md-min) {\n    @content;\n  }\n}\n\n@mixin sm-size() {\n  @include respond-to($screen-sm-min) {\n    @content;\n  }\n}\n\n@mixin xs-size() {\n  @include respond-to($screen-xs-min) {\n    @content;\n  }\n}\n\n@mixin hover {\n  @media (hover: hover) {\n    @content;\n  }\n}\n\n@mixin flex-center {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n}\n\n//  * Generate a responsive css variable\n//  *\n//  * @param {text} $var-to-update: the css variable, --css-var\n//  * @param {SASS Map} $map: must be a sass map containing keys of sm, md, lg, xl\n//  * @param {any} $starting-val: optional, the default value, will set value for xs devices\n//  */\n@mixin make-responsive-var($var-to-update, $map, $starting-val: null) {\n  @if ($starting-val) {\n    #{$var-to-update}: $starting-val;\n  } @else if (map-has-key($map, 'md')) {\n    $val: map.get($map, 'md');\n    #{$var-to-update}: #{$val};\n  } @else if (map-has-key($map, 'lg')) {\n    $val: map.get($map, 'lg');\n    #{$var-to-update}: #{$val};\n  }\n\n  $break-points-in-map: map.keys($map);\n  // this requires the map to container\n  // keys equal to the either (sm, md, lg ,xl or, xxl)\n\n  @each $key /* = sm, md, lg, xl, xxl */ in $break-points-in-map {\n    $bp: map.get($breakpoints, $key); // Get bp by key\n    $val: map.get($map, $key);\n\n    @include respond-to($bp) {\n      #{$var-to-update}: #{$val};\n    }\n  }\n}\n\n//  * Generate a css class with responsive classes\n//  *\n//  * @param {SASS Map} $map: must be a sass map containing only values\n//  * @param {text} $class: the name of the class to output\n//  * @param {text} $property: the css property to effect\n//  */\n@mixin class-with-responsive-val-only($map, $class, $property) {\n  @each $val in $map {\n    .#{$class}-#{$val} {\n      #{$property}: $val;\n    }\n    @each $bp, $px in $breakpoints {\n      @include respond-to(#{$px}) {\n        .#{$class}-#{$bp}-#{$val} {\n          #{$property}: $val !important;\n        }\n      }\n    }\n  }\n}\n\n//  * Generate a css class with responsive classes using key and value from map\n//  *\n//  * @param {SASS Map} $map: must be a sass map containing key value pairs\n//  * @param {text} $class: the css property to effect\n//  * @param {text} $property: the css property to effect\n//  * @param {boolean} $calc-value: toggle for using calcualted value, must be paired with `$var-name`\n//  * @param {CSS var} $var-name: A css var to use for calculating the output value\n//  */\n@mixin class-with-responsive-key-and-val(\n  $map,\n  $class,\n  $property,\n  $calc-value: null,\n  $var-name: null\n) {\n  @each $key, $val in $map {\n    .#{$class}-#{$key} {\n      @if $calc-value and $var-name {\n        @if meta.type-of($property) == 'list' {\n          @each $key in $property {\n            #{$key}: calc($val - var($var-name, 0px));\n          }\n        } @else {\n          #{$property}: calc($val - var($var-name, 0px));\n        }\n      } @else {\n        @if meta.type-of($property) == 'list' {\n          @each $key in $property {\n            #{$key}: $val;\n          }\n        } @else {\n          #{$property}: $val;\n        }\n      }\n    }\n\n    @each $bp, $px in $breakpoints {\n      @include respond-to(#{$px}) {\n        .#{$class}-#{$bp}-#{$key} {\n          @if $calc-value and $var-name {\n            @if meta.type-of($property) == 'list' {\n              @each $key in $property {\n                #{$key}: calc($val - var($var-name, 0px)) !important;\n              }\n            } @else {\n              #{$property}: calc($val - var($var-name, 0px)) !important;\n            }\n          } @else {\n            @if meta.type-of($property) == 'list' {\n              @each $key in $property {\n                #{$key}: $val !important;\n              }\n            } @else {\n              #{$property}: $val !important;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n// * Generate eiather a single transition property, or a list of transitions\n//  *\n//  * @param {SASS list | string} the property to transition\n//  * @param {number?} Transition time\n//  * @param {ease?} Transition Ease\n@mixin transition($target, $time: 300, $ease: ease-in-out) {\n  $transition: ();\n\n  // Check type\n  @if meta.type-of($target) == 'list' {\n    @each $val in $target {\n      // set up transition properties\n      $prop: $val #{$time}ms $ease;\n      // Create comma seperated list of transition properties\n      $transition: append($transition, $prop, comma);\n    }\n  } @else {\n    $transition: $target #{$time}ms $ease;\n  }\n\n  transition: $transition;\n}\n\n@mixin border-rounded($radius: $border-radius) {\n  border-radius: $radius;\n  overflow: hidden;\n}\n\n// @mixin hui_tooltip($content: attr(data-tooltip), $direction: top) {\n//   position: relative;\n//   &:before,\n//   &:after {\n//     display: none;\n//     z-index: 98;\n//   }\n//   &:hover {\n//     &:after {\n//       // for text bubble\n//       content: $content;\n//       display: block;\n//       position: absolute;\n//       height: 12px; // (makes total height including padding 22px)\n//       padding: 6px;\n//       font-size: 12px;\n//       white-space: nowrap;\n//       color: #fff;\n//       @include text-shadow(1px 1px #000);\n//       background-color: #222;\n//     }\n//     @if ($direction == 'top') {\n//       &:before {\n//         @include triangle(down, 6px, #222);\n//         top: -6px;\n//         margin-top: 0;\n//         left: 47%;\n//       }\n//       &:after {\n//         top: -28px;\n//         left: 47%;\n//         margin-left: -20px;\n//       }\n//     } @else if ($direction == 'bottom') {\n//       &:before {\n//         @include triangle(up, 6px, #222);\n//         top: auto;\n//         margin-top: 0;\n//         bottom: -6px;\n//         left: 47%;\n//       }\n//       &:after {\n//         bottom: -28px;\n//         left: 47%;\n//         margin-left: -20px;\n//       }\n//     }\n//   }\n// }\n"]}